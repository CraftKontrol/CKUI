<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CKUI Support - Help Troubleshooting Assistant</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header class="header">
        <div class="header-title">
            <h1>CKUI Support Assistant</h1>
            <p>Help Troubleshooting Chatbot</p>
        </div>
        <div class="credits">
            <span>Artcraft Visuals Â© 2025</span>
        </div>
    </header>

    <section class="api-key-section" id="apiKeySection">
        <label for="apiKey">Mistral API Key:</label>
        <input type="password" id="apiKey" placeholder="Enter your Mistral API key..." />
        <div class="api-key-controls">
            <label class="remember-key-label">
                <input type="checkbox" id="rememberKey" />
                Remember API Key
            </label>
            <button class="clear-key-button" id="clearKeyBtn" onclick="clearSavedApiKey()">Clear Saved Key</button>
        </div>
        <span class="saved-key-indicator" id="savedKeyIndicator">âœ“ Using saved key</span>
        <span class="hint">Get your API key from <a href="https://console.mistral.ai/" target="_blank" rel="noopener noreferrer">Mistral AI Console</a></span>
    </section>

    <div class="security-notice" id="securityNotice">
        <p><strong>ðŸ”’ Security Notice:</strong> Your API key is stored locally in your browser's localStorage and is only sent to Mistral AI servers. Clear saved keys on shared computers.</p>
    </div>

    <main class="chat-container">
        <div id="Logo" >
        
            <img src="https://github.com/user-attachments/assets/b3413eec-c39a-4d50-a23b-e77bf7ff7962" class="chat-logo" alt="CKUI Logo" />
        </div>
        <div class="chat-messages" id="chatMessages">
            <div class="welcome-message" id="welcomeMessage">
                <h2>Welcome to the AI CKUI Support</h2>
                <p>I'm here to help you troubleshoot CKUI modules for TouchDesigner.</p>
                <p>Ask me anything about CKUI setup, configuration, or issues you're facing.</p>
            </div>
        </div>

        <div class="input-container">
            <div class="input-wrapper">
                <textarea 
                    id="userInput" 
                    placeholder="Ask about CKUI modules, TouchDesigner setup, troubleshooting..." 
                    rows="1"
                    onkeydown="handleKeyDown(event)"
                ></textarea>
                <button class="send-button" id="sendButton" onclick="sendMessage()">
                    Send
                </button>
            </div>
        </div>
        <div class="footer">
            <p>Arnaud Cassone Â© Artcraft Visuals 2025</p>
            <p>CKUI is part of the CKLib library</p>
            <a href="http://wwww.artcraft-zone.com" target="_blank" rel="noopener noreferrer">www.artcraft-zone.com</a>
        </div>
    </main>

    <script>
        // CKUI Knowledge Base - Context for the chatbot
        const CKUI_CONTEXT = `
You are a helpful assistant specialized in CKUI (CraftKontrol UI) modules for TouchDesigner. 
You help users troubleshoot and understand the CKUI System.

CKUI System Overview:
- CKUI is a user interface framework designed for interactive installations an performances in TouchDesigner
- It is part of the CKLib library, providing tools for building interactive experiences, reserved for Artcraft Visuals projects.
- CKUI includes a Project Manager for managing project settings and configurations.
- It has a main UI module used to grab and show the modules found in the project.
- CKUI supports multiple sensors including Kinect Azure, Leap Motion, and Lidar sensors.
- It features a Content Manager for handling media assets, 3d scenes and libraries.
- CKUI has a robust audio system for threading sound input and output.
- CKUI has a Web Logger for logging events and errors to a web interface.
- Author: Arnaud Cassone Â© Artcraft Visuals

Wiki links:

https://github.com/CraftKontrol/CKUI/wiki/Home - Main overview of CKUI
https://github.com/CraftKontrol/CKUI/wiki/Audio - Audio system documentation
https://github.com/CraftKontrol/CKUI/wiki/Content-Manager - Content management features
https://github.com/CraftKontrol/CKUI/wiki/Kinect-Azure - Kinect Azure integration
https://github.com/CraftKontrol/CKUI/wiki/Leap-Motion - Leap Motion sensor support
https://github.com/CraftKontrol/CKUI/wiki/MultiLidarAreaBlob - Lidar blob detection
https://github.com/CraftKontrol/CKUI/wiki/Output - Output monitor configuration
https://github.com/CraftKontrol/CKUI/wiki/ProjectManager - Project management tools
https://github.com/CraftKontrol/CKUI/wiki/Rendering - Rendering pipeline
https://github.com/CraftKontrol/CKUI/wiki/Sensors - Sensor integration
https://github.com/CraftKontrol/CKUI/wiki/Stereo-Engine - Stereo processing
https://github.com/CraftKontrol/CKUI/wiki/System - System config load/save & state machine configuration
https://github.com/CraftKontrol/CKUI/wiki/Ui - User interface
https://github.com/CraftKontrol/CKUI/wiki/WebLogger - Web logging functionality


When answering questions:
- Read all the relevant wiki sections before answering.
- Only respond when directly asked questions about CKUI.
- Base all answers exclusively on the provided wiki pages parameters and topics.
- ALWAYS provide step-by-step numbered instructions when explaining how to do something. Use numbered lists (1., 2., 3., etc.) for sequential steps.
- Preserve and display code snippets using <pre><code> tags for proper formatting.
- Always include relevant links to wiki sections in <a href= for further reading.
- Do not use markdown format in your answers. Use HTML tags instead.
- Keep responses focused and accurate to the documentation.
- When wiki content includes images, include them in your response to help illustrate the instructions.
- Include images from the wiki content when available using HTML img tags: <img src="URL" alt="description">
- use the original image URLs from the wiki without modification.


`;

        let conversationHistory = [];
        let isLoading = false;
        const MIN_API_KEY_LENGTH = 10;

        // Hide API key section and security notice
        function hideApiKeySection() {
            document.getElementById('apiKeySection').style.display = 'none';
            document.getElementById('securityNotice').style.display = 'none';
        }

        // Show API key section and security notice
        function showApiKeySection() {
            document.getElementById('apiKeySection').style.display = 'block';
            document.getElementById('securityNotice').style.display = 'block';
        }

        // Load saved API key from localStorage on page load
        document.addEventListener('DOMContentLoaded', function() {
            const savedApiKey = localStorage.getItem('mistralApiKey');
            if (savedApiKey) {
                document.getElementById('apiKey').value = savedApiKey;
                document.getElementById('rememberKey').checked = true;
                updateSavedKeyIndicator(true);
            } else {
                updateSavedKeyIndicator(false);
            }

            // Hide API key section when user enters a key (more than MIN_API_KEY_LENGTH characters)
            document.getElementById('apiKey').addEventListener('input', function() {
                if (this.value.length > MIN_API_KEY_LENGTH) {
                    hideApiKeySection();
                } else {
                    showApiKeySection();
                }
            });
        });

        // Update the saved key indicator visibility
        function updateSavedKeyIndicator(hasSavedKey) {
            const indicator = document.getElementById('savedKeyIndicator');
            const clearBtn = document.getElementById('clearKeyBtn');
            if (hasSavedKey) {
                indicator.style.display = 'inline';
                clearBtn.style.display = 'inline-block';
                hideApiKeySection();
            } else {
                indicator.style.display = 'none';
                clearBtn.style.display = 'none';
            }
        }

        // Clear saved API key from localStorage
        function clearSavedApiKey() {
            localStorage.removeItem('mistralApiKey');
            document.getElementById('apiKey').value = '';
            document.getElementById('rememberKey').checked = false;
            updateSavedKeyIndicator(false);
            showApiKeySection();
        }

        // Map wiki topics to URLs
        const CKUI_WIKI_TOPICS = {
            "audio": "Audio",
            "content manager": "Content-Manager",
            "kinect azure": "Kinect-Azure",
            "leap motion": "Leap-Motion",
            "multilidarareablob": "MultiLidarAreaBlob",
            "output": "Output",
            "project manager": "ProjectManager",
            "rendering": "Rendering",
            "sensors": "Sensors",
            "stereo engine": "Stereo-Engine",
            "system": "System",
            "ui": "Ui",
            "web logger": "WebLogger"
        };

        // Util: Find matching wiki topic(s) - returns array of topics
        function findWikiTopics(query) {
            const lowerQuery = query.toLowerCase();
            const matchedTopics = Object.keys(CKUI_WIKI_TOPICS).filter((key) =>
                lowerQuery.includes(key)
            );
            return matchedTopics.map(topic => CKUI_WIKI_TOPICS[topic]);
        }

        // Util: Find single matching wiki topic (for backward compatibility)
        function findWikiTopic(query) {
            const topics = findWikiTopics(query);
            return topics.length > 0 ? topics[0] : null;
        }

        // Util: Extract images from markdown content and convert to HTML
        function extractImagesFromMarkdown(content) {
            // Match markdown image syntax: ![alt](url)
            const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
            // Also match HTML img tags that might already be in the content
            const htmlImgRegex = /<img[^>]+src=["']([^"']+)["'][^>]*alt=["']([^"']*)["'][^>]*>/gi;
            
            const images = [];
            let match;
            
            // Extract markdown images
            while ((match = imageRegex.exec(content)) !== null) {
                images.push({
                    alt: match[1] || 'Image',
                    url: match[2]
                });
            }
            
            // Extract existing HTML images with alt text
            while ((match = htmlImgRegex.exec(content)) !== null) {
                images.push({
                    alt: match[2] || 'Image',
                    url: match[1]
                });
            }
            
            return images;
        }

        // Util: Convert markdown images to HTML in content
        function convertMarkdownImagesToHtml(content) {
            // Convert markdown images ![alt](url) to HTML <img src="url" alt="alt">
            // Styling is handled by CSS class .message-content img
            return content.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1">');
        }

        // Util: Fetch wiki raw content using GitHub API for public wiki pages
        // Now preserves images and returns enhanced content with images converted to HTML
        async function fetchWikiContent(page) {
            const url = `https://raw.githubusercontent.com/wiki/CraftKontrol/CKUI/${page}.md`;
            try {
                const response = await fetch(url);
                if (response.ok) {
                    let content = await response.text();
                    // Extract images before any processing
                    const images = extractImagesFromMarkdown(content);
                    // Convert markdown images to HTML for better display
                    content = convertMarkdownImagesToHtml(content);
                    return {
                        content: content,
                        images: images
                    };
                }
                return { content: '', images: [] };
            } catch {
                return { content: '', images: [] };
            }
        }

        // Util: Fetch multiple wiki pages and combine their content
        async function fetchMultipleWikiContents(pages) {
            const results = await Promise.all(pages.map(page => fetchWikiContent(page)));
            let combinedContent = '';
            let allImages = [];
            
            results.forEach((result, index) => {
                if (result.content) {
                    combinedContent += `\n\n=== ${pages[index]} ===\n${result.content}`;
                    allImages = allImages.concat(result.images);
                }
            });
            
            return {
                content: combinedContent,
                images: allImages
            };
        }

        // Auto-resize textarea
        const textarea = document.getElementById('userInput');
        textarea.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 200) + 'px';
        });

        function handleKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        function askQuestion(question) {
            document.getElementById('userInput').value = question;
            sendMessage();
        }

        async function sendMessage() {
            const input = document.getElementById('userInput');
            const message = input.value.trim();
            const apiKeyInput = document.getElementById('apiKey');
            const apiKey = apiKeyInput.value.trim();

            if (!apiKey) {
                showError('Please enter your Mistral API key to continue.');
                return;
            }

            if (!message || isLoading) return;

            // Save API key if remember checkbox is checked
            const rememberKey = document.getElementById('rememberKey').checked;
            if (rememberKey) {
                localStorage.setItem('mistralApiKey', apiKey);
                updateSavedKeyIndicator(true);
            }

            // Hide API key section after first message
            hideApiKeySection();

            // Hide welcome message
            const welcomeMsg = document.getElementById('welcomeMessage');
            if (welcomeMsg) {
                welcomeMsg.style.display = 'none';
            }

            // Add user message to UI
            addMessage(message, 'user');
            input.value = '';
            input.style.height = 'auto';

            // Add to conversation history
            conversationHistory.push({
                role: 'user',
                content: message
            });

            // Show typing indicator
            showTypingIndicator();
            isLoading = true;
            document.getElementById('sendButton').disabled = true;

            try {
                const response = await callMistralAPI(apiKey, message);
                hideTypingIndicator();
                
                // Add assistant message to UI
                addMessage(response, 'assistant');
                
                // Add to conversation history
                conversationHistory.push({
                    role: 'assistant',
                    content: response
                });
            } catch (error) {
                hideTypingIndicator();
                showError(error.message);
            } finally {
                isLoading = false;
                document.getElementById('sendButton').disabled = false;
            }
        }

        // Updated to inject wiki content before API call, if relevant
        // Now supports multiple wiki topics and includes images
        async function callMistralAPI(apiKey, userMessage) {
            let wikiReferences = [];
            let wikiContext = '';
            let wikiImages = [];

            // 1. Detect if the user is referencing wiki topic(s) - now supports multiple topics
            const topicPages = findWikiTopics(userMessage);
            
            if (topicPages.length > 0) {
                // Fetch content for all matched topics
                const wikiResult = await fetchMultipleWikiContents(topicPages);
                wikiContext = wikiResult.content;
                wikiImages = wikiResult.images;
                
                // Build references for all matched topics
                wikiReferences = topicPages.map(page => 
                    `https://github.com/CraftKontrol/CKUI/wiki/${page}`
                );
                
                if (wikiContext) {
                    // Increased context size limit from 3000 to 8000 characters
                    wikiContext = wikiContext.slice(0, 8000);
                }
            }

            // Build image context for the AI
            let imageContext = '';
            if (wikiImages.length > 0) {
                imageContext = '\n\nAvailable images from wiki (include relevant ones in your response using HTML img tags):\n';
                wikiImages.forEach((img, index) => {
                    imageContext += `Image ${index + 1}: <img src="${img.url}" alt="${img.alt}">\n`;
                });
            }

            const messages = [
                {
                    role: 'system',
                    content: CKUI_CONTEXT + (wikiContext
                        ? `\n\nCKUI Wiki Content for "${topicPages.join(', ')}":\n\n${wikiContext}${imageContext}\n\nWiki References: ${wikiReferences.join(', ')}\n`
                        : ''
                    )
                },
                ...conversationHistory
            ];

            const response = await fetch('https://api.mistral.ai/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'mistral-small-latest',
                    messages: messages,
                    temperature: 0.7,
                    max_tokens: 2048
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                if (response.status === 401) {
                    throw new Error('Invalid API key. Please check your Mistral API key.');
                } else if (response.status === 429) {
                    throw new Error('Rate limit exceeded. Please wait a moment and try again.');
                } else {
                    throw new Error(errorData.message || `API error: ${response.status}`);
                }
            }

            const data = await response.json();
            
            // Validate API response structure
            if (!data || !data.choices || !Array.isArray(data.choices) || data.choices.length === 0) {
                throw new Error('Invalid response from API. Please try again.');
            }
            
            let answer = data.choices[0].message.content;
            
            // Append the direct wiki links to the assistant's response
            if (wikiReferences.length > 0) {
                const missingRefs = wikiReferences.filter(ref => !answer.includes(ref));
                if (missingRefs.length > 0) {
                    answer += '<br><br>See the official wiki page(s):<br>';
                    missingRefs.forEach(ref => {
                        answer += `<a href="${ref}" target="_blank">${ref}</a><br>`;
                    });
                }
            }
            return answer;
        }

        function addMessage(content, role) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;

            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = role === 'user' ? 'ðŸ‘¤' : 'ðŸ¤–';

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.innerHTML = formatMessage(content);

            messageDiv.appendChild(avatar);
            messageDiv.appendChild(contentDiv);
            chatMessages.appendChild(messageDiv);

            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function formatMessage(content) {
            // Convert markdown-style content to HTML
            let formatted = content
                // Convert markdown images ![alt](url) to HTML img tags
                .replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1">')
                // Convert code blocks
                .replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
                // Convert inline code
                .replace(/`([^`]+)`/g, '<code>$1</code>')
                // Convert bold text
                .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                // Convert italic text
                .replace(/\*([^*]+)\*/g, '<em>$1</em>')
                // Convert markdown links [text](url) to HTML anchors
                // Note: Image links are already converted above, so remaining [text](url) patterns are regular links
                .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>')
                // Convert newlines to line breaks
                .replace(/\n/g, '<br>');

            return formatted;
        }

        function showTypingIndicator() {
            const chatMessages = document.getElementById('chatMessages');
            const typingDiv = document.createElement('div');
            typingDiv.className = 'message assistant';
            typingDiv.id = 'typingIndicator';

            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = 'ðŸ¤–';

            const indicator = document.createElement('div');
            indicator.className = 'typing-indicator';
            indicator.innerHTML = '<span></span><span></span><span></span>';

            typingDiv.appendChild(avatar);
            typingDiv.appendChild(indicator);
            chatMessages.appendChild(typingDiv);

            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function hideTypingIndicator() {
            const indicator = document.getElementById('typingIndicator');
            if (indicator) {
                indicator.remove();
            }
        }

        function showError(message) {
            const chatMessages = document.getElementById('chatMessages');
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            chatMessages.appendChild(errorDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    </script>
</body>
</html>
